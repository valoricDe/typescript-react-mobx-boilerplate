type Answer implements Node {
  # A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  id: ID!
  rowId: Int!
  text: NonEmptyText!
  question: Int!
  author: Int!
  answerVoteByCurrentUser: AnswerVote
  vote: Int

  # Reads a single `Question` that is related to this `Answer`.
  questionByQuestion: Question

  # Reads a single `User` that is related to this `Answer`.
  userByAuthor: User

  # Reads and enables paginatation through a set of `AnswerVote`.
  answerVotesByAnswer(
    # The method to use when ordering `AnswerVote`.
    orderBy: AnswerVotesOrderBy = PRIMARY_KEY_ASC

    # Read all values in the set before (above) this cursor.
    before: Cursor

    # Read all values in the set after (below) this cursor.
    after: Cursor

    # Only read the first `n` values of the set.
    first: Int

    # Only read the last `n` values of the set.
    last: Int

    # Skip the first `n` values from our `after` cursor, an alternative to cursor
    # based pagination. May not be used with `last`.
    offset: Int

    # A condition to be used in determining which values should be returned by the collection.
    condition: AnswerVoteCondition
  ): AnswerVotesConnection
}

# All input for the `answerAnswerVoteCount` mutation.
input AnswerAnswerVoteCountInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String
  questionId: Int
  answerId: Int
  value: Int
  subscribe: Boolean
}

# The output of our `answerAnswerVoteCount` mutation.
type AnswerAnswerVoteCountPayload {
  # The exact same `clientMutationId` that was provided in the mutation input,
  # unchanged and unused. May be used by a client to track mutations.
  clientMutationId: String
  string: String

  # Our root query field type. Allows us to run any query from our mutation payload.
  query: Query
}

# All input for the `answerAnswerVote` mutation.
input AnswerAnswerVoteInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String
  answer: AnswerInput
  value: Int
  subscribe: Boolean
}

# The output of our `answerAnswerVote` mutation.
type AnswerAnswerVotePayload {
  # The exact same `clientMutationId` that was provided in the mutation input,
  # unchanged and unused. May be used by a client to track mutations.
  clientMutationId: String
  string: String

  # Our root query field type. Allows us to run any query from our mutation payload.
  query: Query
}

# A condition to be used against `Answer` object types. All fields are tested for equality and combined with a logical ‘and.’
input AnswerCondition {
  # Checks for equality with the object’s `rowId` field.
  rowId: Int

  # Checks for equality with the object’s `text` field.
  text: NonEmptyText

  # Checks for equality with the object’s `question` field.
  question: Int

  # Checks for equality with the object’s `author` field.
  author: Int
}

input AnswerInput {
  rowId: Int
  text: NonEmptyText!
  question: Int!
  author: Int!
}

# Represents an update to a `Answer`. Fields that are set will be updated.
input AnswerPatch {
  rowId: Int
  text: NonEmptyText
  question: Int
  author: Int
}

# A connection to a list of `Answer` values.
type AnswersConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # The count of *all* `Answer` you could get from the connection.
  totalCount: Int

  # A list of edges which contains the `Answer` and cursor to aid in pagination.
  edges: [AnswersEdge]

  # A list of `Answer` objects.
  nodes: [Answer!]
}

# A `Answer` edge in the connection.
type AnswersEdge {
  # A cursor for use in pagination.
  cursor: Cursor

  # The `Answer` at the end of the edge.
  node: Answer!
}

# Methods to use when ordering `Answer`.
enum AnswersOrderBy {
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  NATURAL
  ID_ASC
  ID_DESC
  TEXT_ASC
  TEXT_DESC
  QUESTION_ASC
  QUESTION_DESC
  AUTHOR_ASC
  AUTHOR_DESC
}

type AnswerVote implements Node {
  # A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  id: ID!
  user: Int!
  question: Int!
  answer: Int!
  subscribe: Boolean
  value: PositiveOrNegativeOne

  # Reads a single `User` that is related to this `AnswerVote`.
  userByUser: User

  # Reads a single `Question` that is related to this `AnswerVote`.
  questionByQuestion: Question

  # Reads a single `Answer` that is related to this `AnswerVote`.
  answerByAnswer: Answer
}

# A condition to be used against `AnswerVote` object types. All fields are tested
# for equality and combined with a logical ‘and.’
input AnswerVoteCondition {
  # Checks for equality with the object’s `user` field.
  user: Int

  # Checks for equality with the object’s `question` field.
  question: Int

  # Checks for equality with the object’s `answer` field.
  answer: Int

  # Checks for equality with the object’s `subscribe` field.
  subscribe: Boolean

  # Checks for equality with the object’s `value` field.
  value: PositiveOrNegativeOne
}

input AnswerVoteInput {
  user: Int!
  question: Int!
  answer: Int!
  subscribe: Boolean
  value: PositiveOrNegativeOne
}

# Represents an update to a `AnswerVote`. Fields that are set will be updated.
input AnswerVotePatch {
  user: Int
  question: Int
  answer: Int
  subscribe: Boolean
  value: PositiveOrNegativeOne
}

# A connection to a list of `AnswerVote` values.
type AnswerVotesConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # The count of *all* `AnswerVote` you could get from the connection.
  totalCount: Int

  # A list of edges which contains the `AnswerVote` and cursor to aid in pagination.
  edges: [AnswerVotesEdge]

  # A list of `AnswerVote` objects.
  nodes: [AnswerVote!]
}

# A `AnswerVote` edge in the connection.
type AnswerVotesEdge {
  # A cursor for use in pagination.
  cursor: Cursor

  # The `AnswerVote` at the end of the edge.
  node: AnswerVote!
}

# Methods to use when ordering `AnswerVote`.
enum AnswerVotesOrderBy {
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  NATURAL
  USER_ASC
  USER_DESC
  QUESTION_ASC
  QUESTION_DESC
  ANSWER_ASC
  ANSWER_DESC
  SUBSCRIBE_ASC
  SUBSCRIBE_DESC
  VALUE_ASC
  VALUE_DESC
}

# All input for the `authenticate` mutation.
input AuthenticateInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String
  email: String!
  password: String!
}

# The output of our `authenticate` mutation.
type AuthenticatePayload {
  # The exact same `clientMutationId` that was provided in the mutation input,
  # unchanged and unused. May be used by a client to track mutations.
  clientMutationId: String
  jwtToken: JwtToken

  # Our root query field type. Allows us to run any query from our mutation payload.
  query: Query
}

# All input for the `createAnswer` mutation.
input CreateAnswerInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The `Answer` to be created by this mutation.
  answer: AnswerInput!
}

# The output of our `createAnswer` mutation.
type CreateAnswerPayload {
  # The exact same `clientMutationId` that was provided in the mutation input,
  # unchanged and unused. May be used by a client to track mutations.
  clientMutationId: String

  # The `Answer` that was created by this mutation.
  answer: Answer

  # An edge for our `Answer`. May be used by Relay 1.
  answerEdge(
    # The method to use when ordering `Answer`.
    orderBy: AnswersOrderBy = PRIMARY_KEY_ASC
  ): AnswersEdge

  # Reads a single `Question` that is related to this `Answer`.
  questionByQuestion: Question

  # Reads a single `User` that is related to this `Answer`.
  userByAuthor: User

  # Our root query field type. Allows us to run any query from our mutation payload.
  query: Query
}

# All input for the `createAnswerVote` mutation.
input CreateAnswerVoteInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The `AnswerVote` to be created by this mutation.
  answerVote: AnswerVoteInput!
}

# The output of our `createAnswerVote` mutation.
type CreateAnswerVotePayload {
  # The exact same `clientMutationId` that was provided in the mutation input,
  # unchanged and unused. May be used by a client to track mutations.
  clientMutationId: String

  # The `AnswerVote` that was created by this mutation.
  answerVote: AnswerVote

  # An edge for our `AnswerVote`. May be used by Relay 1.
  answerVoteEdge(
    # The method to use when ordering `AnswerVote`.
    orderBy: AnswerVotesOrderBy = PRIMARY_KEY_ASC
  ): AnswerVotesEdge

  # Reads a single `User` that is related to this `AnswerVote`.
  userByUser: User

  # Reads a single `Question` that is related to this `AnswerVote`.
  questionByQuestion: Question

  # Reads a single `Answer` that is related to this `AnswerVote`.
  answerByAnswer: Answer

  # Our root query field type. Allows us to run any query from our mutation payload.
  query: Query
}

# All input for the `createQuestion` mutation.
input CreateQuestionInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The `Question` to be created by this mutation.
  question: QuestionInput!
}

# All input for the `createQuestionModel` mutation.
input CreateQuestionModelInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The `QuestionModel` to be created by this mutation.
  questionModel: QuestionModelInput!
}

# The output of our `createQuestionModel` mutation.
type CreateQuestionModelPayload {
  # The exact same `clientMutationId` that was provided in the mutation input,
  # unchanged and unused. May be used by a client to track mutations.
  clientMutationId: String

  # The `QuestionModel` that was created by this mutation.
  questionModel: QuestionModel

  # An edge for our `QuestionModel`. May be used by Relay 1.
  questionModelEdge(
    # The method to use when ordering `QuestionModel`.
    orderBy: QuestionModelsOrderBy = NATURAL
  ): QuestionModelsEdge

  # Reads a single `Question` that is related to this `QuestionModel`.
  questionByQuestionid: Question

  # Our root query field type. Allows us to run any query from our mutation payload.
  query: Query
}

# The output of our `createQuestion` mutation.
type CreateQuestionPayload {
  # The exact same `clientMutationId` that was provided in the mutation input,
  # unchanged and unused. May be used by a client to track mutations.
  clientMutationId: String

  # The `Question` that was created by this mutation.
  question: Question

  # An edge for our `Question`. May be used by Relay 1.
  questionEdge(
    # The method to use when ordering `Question`.
    orderBy: QuestionsOrderBy = PRIMARY_KEY_ASC
  ): QuestionsEdge

  # Reads a single `User` that is related to this `Question`.
  userByAuthor: User

  # Our root query field type. Allows us to run any query from our mutation payload.
  query: Query
}

# All input for the `createQuestionTag` mutation.
input CreateQuestionTagInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The `QuestionTag` to be created by this mutation.
  questionTag: QuestionTagInput!
}

# The output of our `createQuestionTag` mutation.
type CreateQuestionTagPayload {
  # The exact same `clientMutationId` that was provided in the mutation input,
  # unchanged and unused. May be used by a client to track mutations.
  clientMutationId: String

  # The `QuestionTag` that was created by this mutation.
  questionTag: QuestionTag

  # An edge for our `QuestionTag`. May be used by Relay 1.
  questionTagEdge(
    # The method to use when ordering `QuestionTag`.
    orderBy: QuestionTagsOrderBy = NATURAL
  ): QuestionTagsEdge

  # Reads a single `Question` that is related to this `QuestionTag`.
  questionByQuestion: Question

  # Reads a single `Tag` that is related to this `QuestionTag`.
  tagByTag: Tag

  # Our root query field type. Allows us to run any query from our mutation payload.
  query: Query
}

# All input for the `createQuestionVote` mutation.
input CreateQuestionVoteInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The `QuestionVote` to be created by this mutation.
  questionVote: QuestionVoteInput!
}

# The output of our `createQuestionVote` mutation.
type CreateQuestionVotePayload {
  # The exact same `clientMutationId` that was provided in the mutation input,
  # unchanged and unused. May be used by a client to track mutations.
  clientMutationId: String

  # The `QuestionVote` that was created by this mutation.
  questionVote: QuestionVote

  # An edge for our `QuestionVote`. May be used by Relay 1.
  questionVoteEdge(
    # The method to use when ordering `QuestionVote`.
    orderBy: QuestionVotesOrderBy = PRIMARY_KEY_ASC
  ): QuestionVotesEdge

  # Reads a single `User` that is related to this `QuestionVote`.
  userByUser: User

  # Reads a single `Question` that is related to this `QuestionVote`.
  questionByQuestion: Question

  # Our root query field type. Allows us to run any query from our mutation payload.
  query: Query
}

# All input for the `createQuestionWithTags` mutation.
input CreateQuestionWithTagsInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String
  title: NonEmptyText
  description: NonEmptyText
  author: Int
  tagIds: [Int]
}

# The output of our `createQuestionWithTags` mutation.
type CreateQuestionWithTagsPayload {
  # The exact same `clientMutationId` that was provided in the mutation input,
  # unchanged and unused. May be used by a client to track mutations.
  clientMutationId: String
  question: Question

  # An edge for the type. May be used by Relay 1.
  questionEdge(
    # The method to use when ordering `Question`.
    orderBy: QuestionsOrderBy = PRIMARY_KEY_ASC
  ): QuestionsEdge

  # Reads a single `User` that is related to this `Question`.
  userByAuthor: User

  # Our root query field type. Allows us to run any query from our mutation payload.
  query: Query
}

# All input for the `createTag` mutation.
input CreateTagInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The `Tag` to be created by this mutation.
  tag: TagInput!
}

# The output of our `createTag` mutation.
type CreateTagPayload {
  # The exact same `clientMutationId` that was provided in the mutation input,
  # unchanged and unused. May be used by a client to track mutations.
  clientMutationId: String

  # The `Tag` that was created by this mutation.
  tag: Tag

  # An edge for our `Tag`. May be used by Relay 1.
  tagEdge(
    # The method to use when ordering `Tag`.
    orderBy: TagsOrderBy = PRIMARY_KEY_ASC
  ): TagsEdge

  # Reads a single `Tag` that is related to this `Tag`.
  tagByParent: Tag

  # Our root query field type. Allows us to run any query from our mutation payload.
  query: Query
}

# All input for the `createTagRelation` mutation.
input CreateTagRelationInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The `TagRelation` to be created by this mutation.
  tagRelation: TagRelationInput!
}

# The output of our `createTagRelation` mutation.
type CreateTagRelationPayload {
  # The exact same `clientMutationId` that was provided in the mutation input,
  # unchanged and unused. May be used by a client to track mutations.
  clientMutationId: String

  # The `TagRelation` that was created by this mutation.
  tagRelation: TagRelation

  # An edge for our `TagRelation`. May be used by Relay 1.
  tagRelationEdge(
    # The method to use when ordering `TagRelation`.
    orderBy: TagRelationsOrderBy = PRIMARY_KEY_ASC
  ): TagRelationsEdge

  # Reads a single `Tag` that is related to this `TagRelation`.
  tagByTag1: Tag

  # Reads a single `Tag` that is related to this `TagRelation`.
  tagByTag2: Tag

  # Our root query field type. Allows us to run any query from our mutation payload.
  query: Query
}

# All input for the `createUser` mutation.
input CreateUserInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The `User` to be created by this mutation.
  user: UserInput!
}

# The output of our `createUser` mutation.
type CreateUserPayload {
  # The exact same `clientMutationId` that was provided in the mutation input,
  # unchanged and unused. May be used by a client to track mutations.
  clientMutationId: String

  # The `User` that was created by this mutation.
  user: User

  # An edge for our `User`. May be used by Relay 1.
  userEdge(
    # The method to use when ordering `User`.
    orderBy: UsersOrderBy = PRIMARY_KEY_ASC
  ): UsersEdge

  # Our root query field type. Allows us to run any query from our mutation payload.
  query: Query
}

# A location in a connection that can be used for resuming pagination.
scalar Cursor

# A point in time as described by the [ISO
# 8601](https://en.wikipedia.org/wiki/ISO_8601) standard. May or may not include a timezone.
scalar Datetime

# All input for the `deleteAnswerByRowId` mutation.
input DeleteAnswerByRowIdInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String
  rowId: Int!
}

# All input for the `deleteAnswer` mutation.
input DeleteAnswerInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The globally unique `ID` which will identify a single `Answer` to be deleted.
  id: ID!
}

# The output of our `deleteAnswer` mutation.
type DeleteAnswerPayload {
  # The exact same `clientMutationId` that was provided in the mutation input,
  # unchanged and unused. May be used by a client to track mutations.
  clientMutationId: String
  answer: Answer
  deletedAnswerId: ID

  # Reads a single `Question` that is related to this `Answer`.
  questionByQuestion: Question

  # Reads a single `User` that is related to this `Answer`.
  userByAuthor: User

  # Our root query field type. Allows us to run any query from our mutation payload.
  query: Query
}

# All input for the `deleteAnswerVoteByUserAndQuestionAndAnswer` mutation.
input DeleteAnswerVoteByUserAndQuestionAndAnswerInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String
  user: Int!
  question: Int!
  answer: Int!
}

# All input for the `deleteAnswerVote` mutation.
input DeleteAnswerVoteInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The globally unique `ID` which will identify a single `AnswerVote` to be deleted.
  id: ID!
}

# The output of our `deleteAnswerVote` mutation.
type DeleteAnswerVotePayload {
  # The exact same `clientMutationId` that was provided in the mutation input,
  # unchanged and unused. May be used by a client to track mutations.
  clientMutationId: String
  answerVote: AnswerVote
  deletedAnswerVoteId: ID

  # Reads a single `User` that is related to this `AnswerVote`.
  userByUser: User

  # Reads a single `Question` that is related to this `AnswerVote`.
  questionByQuestion: Question

  # Reads a single `Answer` that is related to this `AnswerVote`.
  answerByAnswer: Answer

  # Our root query field type. Allows us to run any query from our mutation payload.
  query: Query
}

# All input for the `deleteQuestionByRowId` mutation.
input DeleteQuestionByRowIdInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String
  rowId: Int!
}

# All input for the `deleteQuestion` mutation.
input DeleteQuestionInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The globally unique `ID` which will identify a single `Question` to be deleted.
  id: ID!
}

# The output of our `deleteQuestion` mutation.
type DeleteQuestionPayload {
  # The exact same `clientMutationId` that was provided in the mutation input,
  # unchanged and unused. May be used by a client to track mutations.
  clientMutationId: String
  question: Question
  deletedQuestionId: ID

  # Reads a single `User` that is related to this `Question`.
  userByAuthor: User

  # Our root query field type. Allows us to run any query from our mutation payload.
  query: Query
}

# All input for the `deleteQuestionVoteByUserAndQuestion` mutation.
input DeleteQuestionVoteByUserAndQuestionInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String
  user: Int!
  question: Int!
}

# All input for the `deleteQuestionVote` mutation.
input DeleteQuestionVoteInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The globally unique `ID` which will identify a single `QuestionVote` to be deleted.
  id: ID!
}

# The output of our `deleteQuestionVote` mutation.
type DeleteQuestionVotePayload {
  # The exact same `clientMutationId` that was provided in the mutation input,
  # unchanged and unused. May be used by a client to track mutations.
  clientMutationId: String
  questionVote: QuestionVote
  deletedQuestionVoteId: ID

  # Reads a single `User` that is related to this `QuestionVote`.
  userByUser: User

  # Reads a single `Question` that is related to this `QuestionVote`.
  questionByQuestion: Question

  # Our root query field type. Allows us to run any query from our mutation payload.
  query: Query
}

# All input for the `deleteTagByRowId` mutation.
input DeleteTagByRowIdInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String
  rowId: Int!
}

# All input for the `deleteTag` mutation.
input DeleteTagInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The globally unique `ID` which will identify a single `Tag` to be deleted.
  id: ID!
}

# The output of our `deleteTag` mutation.
type DeleteTagPayload {
  # The exact same `clientMutationId` that was provided in the mutation input,
  # unchanged and unused. May be used by a client to track mutations.
  clientMutationId: String
  tag: Tag
  deletedTagId: ID

  # Reads a single `Tag` that is related to this `Tag`.
  tagByParent: Tag

  # Our root query field type. Allows us to run any query from our mutation payload.
  query: Query
}

# All input for the `deleteTagRelationByTag1` mutation.
input DeleteTagRelationByTag1Input {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String
  tag1: Int!
}

# All input for the `deleteTagRelation` mutation.
input DeleteTagRelationInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The globally unique `ID` which will identify a single `TagRelation` to be deleted.
  id: ID!
}

# The output of our `deleteTagRelation` mutation.
type DeleteTagRelationPayload {
  # The exact same `clientMutationId` that was provided in the mutation input,
  # unchanged and unused. May be used by a client to track mutations.
  clientMutationId: String
  tagRelation: TagRelation
  deletedTagRelationId: ID

  # Reads a single `Tag` that is related to this `TagRelation`.
  tagByTag1: Tag

  # Reads a single `Tag` that is related to this `TagRelation`.
  tagByTag2: Tag

  # Our root query field type. Allows us to run any query from our mutation payload.
  query: Query
}

# All input for the `deleteUserByRowId` mutation.
input DeleteUserByRowIdInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String
  rowId: Int!
}

# All input for the `deleteUserByUsername` mutation.
input DeleteUserByUsernameInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String
  username: NonEmptyText!
}

# All input for the `deleteUser` mutation.
input DeleteUserInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The globally unique `ID` which will identify a single `User` to be deleted.
  id: ID!
}

# The output of our `deleteUser` mutation.
type DeleteUserPayload {
  # The exact same `clientMutationId` that was provided in the mutation input,
  # unchanged and unused. May be used by a client to track mutations.
  clientMutationId: String
  user: User
  deletedUserId: ID

  # Our root query field type. Allows us to run any query from our mutation payload.
  query: Query
}

# All input for the `genRandomBytes` mutation.
input GenRandomBytesInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String
  arg0: Int!
}

# The output of our `genRandomBytes` mutation.
type GenRandomBytesPayload {
  # The exact same `clientMutationId` that was provided in the mutation input,
  # unchanged and unused. May be used by a client to track mutations.
  clientMutationId: String
  string: String

  # Our root query field type. Allows us to run any query from our mutation payload.
  query: Query
}

# All input for the `genRandomUuid` mutation.
input GenRandomUuidInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String
}

# The output of our `genRandomUuid` mutation.
type GenRandomUuidPayload {
  # The exact same `clientMutationId` that was provided in the mutation input,
  # unchanged and unused. May be used by a client to track mutations.
  clientMutationId: String
  uuid: Uuid

  # Our root query field type. Allows us to run any query from our mutation payload.
  query: Query
}

# A JSON Web Token defined by [RFC 7519](https://tools.ietf.org/html/rfc7519)
# which securely represents claims between two parties.
scalar JwtToken

enum LinkType {
  RELATES_TO
}

# The root mutation type which contains root level fields which mutate data.
type Mutation {
  answerAnswerVote(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: AnswerAnswerVoteInput!
  ): AnswerAnswerVotePayload
  answerAnswerVoteCount(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: AnswerAnswerVoteCountInput!
  ): AnswerAnswerVoteCountPayload
  authenticate(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: AuthenticateInput!
  ): AuthenticatePayload
  createQuestionWithTags(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: CreateQuestionWithTagsInput!
  ): CreateQuestionWithTagsPayload
  genRandomBytes(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: GenRandomBytesInput!
  ): GenRandomBytesPayload
  genRandomUuid(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: GenRandomUuidInput!
  ): GenRandomUuidPayload
  registerUser(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: RegisterUserInput!
  ): RegisterUserPayload
  upsertAnswerVoteByQuestionAndAnswer(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: UpsertAnswerVoteByQuestionAndAnswerInput!
  ): UpsertAnswerVoteByQuestionAndAnswerPayload
  upsertTest(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: UpsertTestInput!
  ): UpsertTestPayload

  # Creates a single `Answer`.
  createAnswer(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: CreateAnswerInput!
  ): CreateAnswerPayload

  # Updates a single `Answer` using its globally unique id and a patch.
  updateAnswer(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: UpdateAnswerInput!
  ): UpdateAnswerPayload

  # Updates a single `Answer` using a unique key and a patch.
  updateAnswerByRowId(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: UpdateAnswerByRowIdInput!
  ): UpdateAnswerPayload

  # Deletes a single `Answer` using its globally unique id.
  deleteAnswer(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: DeleteAnswerInput!
  ): DeleteAnswerPayload

  # Deletes a single `Answer` using a unique key.
  deleteAnswerByRowId(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: DeleteAnswerByRowIdInput!
  ): DeleteAnswerPayload

  # Creates a single `AnswerVote`.
  createAnswerVote(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: CreateAnswerVoteInput!
  ): CreateAnswerVotePayload

  # Updates a single `AnswerVote` using its globally unique id and a patch.
  updateAnswerVote(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: UpdateAnswerVoteInput!
  ): UpdateAnswerVotePayload

  # Updates a single `AnswerVote` using a unique key and a patch.
  updateAnswerVoteByUserAndQuestionAndAnswer(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: UpdateAnswerVoteByUserAndQuestionAndAnswerInput!
  ): UpdateAnswerVotePayload

  # Deletes a single `AnswerVote` using its globally unique id.
  deleteAnswerVote(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: DeleteAnswerVoteInput!
  ): DeleteAnswerVotePayload

  # Deletes a single `AnswerVote` using a unique key.
  deleteAnswerVoteByUserAndQuestionAndAnswer(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: DeleteAnswerVoteByUserAndQuestionAndAnswerInput!
  ): DeleteAnswerVotePayload

  # Creates a single `Question`.
  createQuestion(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: CreateQuestionInput!
  ): CreateQuestionPayload

  # Updates a single `Question` using its globally unique id and a patch.
  updateQuestion(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: UpdateQuestionInput!
  ): UpdateQuestionPayload

  # Updates a single `Question` using a unique key and a patch.
  updateQuestionByRowId(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: UpdateQuestionByRowIdInput!
  ): UpdateQuestionPayload

  # Deletes a single `Question` using its globally unique id.
  deleteQuestion(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: DeleteQuestionInput!
  ): DeleteQuestionPayload

  # Deletes a single `Question` using a unique key.
  deleteQuestionByRowId(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: DeleteQuestionByRowIdInput!
  ): DeleteQuestionPayload

  # Creates a single `QuestionModel`.
  createQuestionModel(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: CreateQuestionModelInput!
  ): CreateQuestionModelPayload

  # Creates a single `QuestionTag`.
  createQuestionTag(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: CreateQuestionTagInput!
  ): CreateQuestionTagPayload

  # Creates a single `QuestionVote`.
  createQuestionVote(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: CreateQuestionVoteInput!
  ): CreateQuestionVotePayload

  # Updates a single `QuestionVote` using its globally unique id and a patch.
  updateQuestionVote(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: UpdateQuestionVoteInput!
  ): UpdateQuestionVotePayload

  # Updates a single `QuestionVote` using a unique key and a patch.
  updateQuestionVoteByUserAndQuestion(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: UpdateQuestionVoteByUserAndQuestionInput!
  ): UpdateQuestionVotePayload

  # Deletes a single `QuestionVote` using its globally unique id.
  deleteQuestionVote(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: DeleteQuestionVoteInput!
  ): DeleteQuestionVotePayload

  # Deletes a single `QuestionVote` using a unique key.
  deleteQuestionVoteByUserAndQuestion(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: DeleteQuestionVoteByUserAndQuestionInput!
  ): DeleteQuestionVotePayload

  # Creates a single `Tag`.
  createTag(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: CreateTagInput!
  ): CreateTagPayload

  # Updates a single `Tag` using its globally unique id and a patch.
  updateTag(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: UpdateTagInput!
  ): UpdateTagPayload

  # Updates a single `Tag` using a unique key and a patch.
  updateTagByRowId(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: UpdateTagByRowIdInput!
  ): UpdateTagPayload

  # Deletes a single `Tag` using its globally unique id.
  deleteTag(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: DeleteTagInput!
  ): DeleteTagPayload

  # Deletes a single `Tag` using a unique key.
  deleteTagByRowId(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: DeleteTagByRowIdInput!
  ): DeleteTagPayload

  # Creates a single `TagRelation`.
  createTagRelation(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: CreateTagRelationInput!
  ): CreateTagRelationPayload

  # Updates a single `TagRelation` using its globally unique id and a patch.
  updateTagRelation(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: UpdateTagRelationInput!
  ): UpdateTagRelationPayload

  # Updates a single `TagRelation` using a unique key and a patch.
  updateTagRelationByTag1(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: UpdateTagRelationByTag1Input!
  ): UpdateTagRelationPayload

  # Deletes a single `TagRelation` using its globally unique id.
  deleteTagRelation(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: DeleteTagRelationInput!
  ): DeleteTagRelationPayload

  # Deletes a single `TagRelation` using a unique key.
  deleteTagRelationByTag1(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: DeleteTagRelationByTag1Input!
  ): DeleteTagRelationPayload

  # Creates a single `User`.
  createUser(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: CreateUserInput!
  ): CreateUserPayload

  # Updates a single `User` using its globally unique id and a patch.
  updateUser(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: UpdateUserInput!
  ): UpdateUserPayload

  # Updates a single `User` using a unique key and a patch.
  updateUserByRowId(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: UpdateUserByRowIdInput!
  ): UpdateUserPayload

  # Updates a single `User` using a unique key and a patch.
  updateUserByUsername(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: UpdateUserByUsernameInput!
  ): UpdateUserPayload

  # Deletes a single `User` using its globally unique id.
  deleteUser(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: DeleteUserInput!
  ): DeleteUserPayload

  # Deletes a single `User` using a unique key.
  deleteUserByRowId(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: DeleteUserByRowIdInput!
  ): DeleteUserPayload

  # Deletes a single `User` using a unique key.
  deleteUserByUsername(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: DeleteUserByUsernameInput!
  ): DeleteUserPayload
}

# An object with a globally unique `ID`.
interface Node {
  # A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  id: ID!
}

scalar NonEmptyText

# Information about pagination in a connection.
type PageInfo {
  # When paginating forwards, are there more items?
  hasNextPage: Boolean!

  # When paginating backwards, are there more items?
  hasPreviousPage: Boolean!

  # When paginating backwards, the cursor to continue.
  startCursor: Cursor

  # When paginating forwards, the cursor to continue.
  endCursor: Cursor
}

scalar PositiveOrNegativeOne

# The root query type which gives access points into the data universe.
type Query implements Node {
  # Fetches an object given its globally unique `ID`.
  node(
    # The globally unique `ID`.
    id: ID!
  ): Node
  crypt(arg0: String!, arg1: String!): String
  currentUser: User
  currentUserId: Int
  dearmor(arg0: String!): String
  decrypt(arg0: String!, arg1: String!, arg2: String!): String
  decryptIv(arg0: String!, arg1: String!, arg2: String!, arg3: String!): String
  encrypt(arg0: String!, arg1: String!, arg2: String!): String
  encryptIv(arg0: String!, arg1: String!, arg2: String!, arg3: String!): String
  pgpKeyId(arg0: String!): String

  # Reads and enables paginatation through a set of `Answer`.
  searchAnswers(
    # The method to use when ordering `Answer`.
    orderBy: SearchAnswersOrderBy = NATURAL

    # Read all values in the set before (above) this cursor.
    before: Cursor

    # Read all values in the set after (below) this cursor.
    after: Cursor

    # Only read the first `n` values of the set.
    first: Int

    # Only read the last `n` values of the set.
    last: Int

    # Skip the first `n` values from our `after` cursor, an alternative to cursor
    # based pagination. May not be used with `last`.
    offset: Int
    questionId: Int
    search: String
  ): SearchAnswersConnection

  # Reads and enables paginatation through a set of `Question`.
  searchQuestions(
    # The method to use when ordering `Question`.
    orderBy: SearchQuestionsOrderBy = NATURAL

    # Read all values in the set before (above) this cursor.
    before: Cursor

    # Read all values in the set after (below) this cursor.
    after: Cursor

    # Only read the first `n` values of the set.
    first: Int

    # Only read the last `n` values of the set.
    last: Int

    # Skip the first `n` values from our `after` cursor, an alternative to cursor
    # based pagination. May not be used with `last`.
    offset: Int
    search: String
  ): SearchQuestionsConnection

  # Reads and enables paginatation through a set of `Tag`.
  searchTags(
    # The method to use when ordering `Tag`.
    orderBy: SearchTagsOrderBy = NATURAL

    # Read all values in the set before (above) this cursor.
    before: Cursor

    # Read all values in the set after (below) this cursor.
    after: Cursor

    # Only read the first `n` values of the set.
    first: Int

    # Only read the last `n` values of the set.
    last: Int

    # Skip the first `n` values from our `after` cursor, an alternative to cursor
    # based pagination. May not be used with `last`.
    offset: Int
    search: String
  ): SearchTagsConnection

  # Reads and enables paginatation through a set of `Tag`.
  tagsByParent(
    # The method to use when ordering `Tag`.
    orderBy: TagsByParentOrderBy = NATURAL

    # Read all values in the set before (above) this cursor.
    before: Cursor

    # Read all values in the set after (below) this cursor.
    after: Cursor

    # Only read the first `n` values of the set.
    first: Int

    # Only read the last `n` values of the set.
    last: Int

    # Skip the first `n` values from our `after` cursor, an alternative to cursor
    # based pagination. May not be used with `last`.
    offset: Int
    parent: Int
  ): TagsByParentConnection

  # Reads and enables paginatation through a set of `Answer`.
  allAnswers(
    # The method to use when ordering `Answer`.
    orderBy: AnswersOrderBy = PRIMARY_KEY_ASC

    # Read all values in the set before (above) this cursor.
    before: Cursor

    # Read all values in the set after (below) this cursor.
    after: Cursor

    # Only read the first `n` values of the set.
    first: Int

    # Only read the last `n` values of the set.
    last: Int

    # Skip the first `n` values from our `after` cursor, an alternative to cursor
    # based pagination. May not be used with `last`.
    offset: Int

    # A condition to be used in determining which values should be returned by the collection.
    condition: AnswerCondition
  ): AnswersConnection

  # Reads a single `Answer` using its globally unique `ID`.
  answer(
    # The globally unique `ID` to be used in selecting a single `Answer`.
    id: ID!
  ): Answer
  answerByRowId(rowId: Int!): Answer

  # Reads and enables paginatation through a set of `AnswerVote`.
  allAnswerVotes(
    # The method to use when ordering `AnswerVote`.
    orderBy: AnswerVotesOrderBy = PRIMARY_KEY_ASC

    # Read all values in the set before (above) this cursor.
    before: Cursor

    # Read all values in the set after (below) this cursor.
    after: Cursor

    # Only read the first `n` values of the set.
    first: Int

    # Only read the last `n` values of the set.
    last: Int

    # Skip the first `n` values from our `after` cursor, an alternative to cursor
    # based pagination. May not be used with `last`.
    offset: Int

    # A condition to be used in determining which values should be returned by the collection.
    condition: AnswerVoteCondition
  ): AnswerVotesConnection

  # Reads a single `AnswerVote` using its globally unique `ID`.
  answerVote(
    # The globally unique `ID` to be used in selecting a single `AnswerVote`.
    id: ID!
  ): AnswerVote
  answerVoteByUserAndQuestionAndAnswer(user: Int!, question: Int!, answer: Int!): AnswerVote

  # Reads and enables paginatation through a set of `Question`.
  allQuestions(
    # The method to use when ordering `Question`.
    orderBy: QuestionsOrderBy = PRIMARY_KEY_ASC

    # Read all values in the set before (above) this cursor.
    before: Cursor

    # Read all values in the set after (below) this cursor.
    after: Cursor

    # Only read the first `n` values of the set.
    first: Int

    # Only read the last `n` values of the set.
    last: Int

    # Skip the first `n` values from our `after` cursor, an alternative to cursor
    # based pagination. May not be used with `last`.
    offset: Int

    # A condition to be used in determining which values should be returned by the collection.
    condition: QuestionCondition
  ): QuestionsConnection

  # Reads a single `Question` using its globally unique `ID`.
  question(
    # The globally unique `ID` to be used in selecting a single `Question`.
    id: ID!
  ): Question
  questionByRowId(rowId: Int!): Question

  # Reads and enables paginatation through a set of `QuestionModel`.
  allQuestionModels(
    # The method to use when ordering `QuestionModel`.
    orderBy: QuestionModelsOrderBy = NATURAL

    # Read all values in the set before (above) this cursor.
    before: Cursor

    # Read all values in the set after (below) this cursor.
    after: Cursor

    # Only read the first `n` values of the set.
    first: Int

    # Only read the last `n` values of the set.
    last: Int

    # Skip the first `n` values from our `after` cursor, an alternative to cursor
    # based pagination. May not be used with `last`.
    offset: Int

    # A condition to be used in determining which values should be returned by the collection.
    condition: QuestionModelCondition
  ): QuestionModelsConnection

  # Reads and enables paginatation through a set of `QuestionTag`.
  allQuestionTags(
    # The method to use when ordering `QuestionTag`.
    orderBy: QuestionTagsOrderBy = NATURAL

    # Read all values in the set before (above) this cursor.
    before: Cursor

    # Read all values in the set after (below) this cursor.
    after: Cursor

    # Only read the first `n` values of the set.
    first: Int

    # Only read the last `n` values of the set.
    last: Int

    # Skip the first `n` values from our `after` cursor, an alternative to cursor
    # based pagination. May not be used with `last`.
    offset: Int

    # A condition to be used in determining which values should be returned by the collection.
    condition: QuestionTagCondition
  ): QuestionTagsConnection

  # Reads and enables paginatation through a set of `QuestionVote`.
  allQuestionVotes(
    # The method to use when ordering `QuestionVote`.
    orderBy: QuestionVotesOrderBy = PRIMARY_KEY_ASC

    # Read all values in the set before (above) this cursor.
    before: Cursor

    # Read all values in the set after (below) this cursor.
    after: Cursor

    # Only read the first `n` values of the set.
    first: Int

    # Only read the last `n` values of the set.
    last: Int

    # Skip the first `n` values from our `after` cursor, an alternative to cursor
    # based pagination. May not be used with `last`.
    offset: Int

    # A condition to be used in determining which values should be returned by the collection.
    condition: QuestionVoteCondition
  ): QuestionVotesConnection

  # Reads a single `QuestionVote` using its globally unique `ID`.
  questionVote(
    # The globally unique `ID` to be used in selecting a single `QuestionVote`.
    id: ID!
  ): QuestionVote
  questionVoteByUserAndQuestion(user: Int!, question: Int!): QuestionVote

  # Reads and enables paginatation through a set of `Tag`.
  allTags(
    # The method to use when ordering `Tag`.
    orderBy: TagsOrderBy = PRIMARY_KEY_ASC

    # Read all values in the set before (above) this cursor.
    before: Cursor

    # Read all values in the set after (below) this cursor.
    after: Cursor

    # Only read the first `n` values of the set.
    first: Int

    # Only read the last `n` values of the set.
    last: Int

    # Skip the first `n` values from our `after` cursor, an alternative to cursor
    # based pagination. May not be used with `last`.
    offset: Int

    # A condition to be used in determining which values should be returned by the collection.
    condition: TagCondition
  ): TagsConnection

  # Reads a single `Tag` using its globally unique `ID`.
  tag(
    # The globally unique `ID` to be used in selecting a single `Tag`.
    id: ID!
  ): Tag
  tagByRowId(rowId: Int!): Tag

  # Reads and enables paginatation through a set of `TagRelation`.
  allTagRelations(
    # The method to use when ordering `TagRelation`.
    orderBy: TagRelationsOrderBy = PRIMARY_KEY_ASC

    # Read all values in the set before (above) this cursor.
    before: Cursor

    # Read all values in the set after (below) this cursor.
    after: Cursor

    # Only read the first `n` values of the set.
    first: Int

    # Only read the last `n` values of the set.
    last: Int

    # Skip the first `n` values from our `after` cursor, an alternative to cursor
    # based pagination. May not be used with `last`.
    offset: Int

    # A condition to be used in determining which values should be returned by the collection.
    condition: TagRelationCondition
  ): TagRelationsConnection

  # Reads a single `TagRelation` using its globally unique `ID`.
  tagRelation(
    # The globally unique `ID` to be used in selecting a single `TagRelation`.
    id: ID!
  ): TagRelation
  tagRelationByTag1(tag1: Int!): TagRelation

  # Reads and enables paginatation through a set of `User`.
  allUsers(
    # The method to use when ordering `User`.
    orderBy: UsersOrderBy = PRIMARY_KEY_ASC

    # Read all values in the set before (above) this cursor.
    before: Cursor

    # Read all values in the set after (below) this cursor.
    after: Cursor

    # Only read the first `n` values of the set.
    first: Int

    # Only read the last `n` values of the set.
    last: Int

    # Skip the first `n` values from our `after` cursor, an alternative to cursor
    # based pagination. May not be used with `last`.
    offset: Int

    # A condition to be used in determining which values should be returned by the collection.
    condition: UserCondition
  ): UsersConnection

  # Reads a single `User` using its globally unique `ID`.
  user(
    # The globally unique `ID` to be used in selecting a single `User`.
    id: ID!
  ): User
  userByRowId(rowId: Int!): User
  userByUsername(username: NonEmptyText!): User

  # Exposes the root query type nested one level down. This is helpful for Relay 1
  # which can only query top level fields if they are in a particular form.
  query: Query!

  # The root query type must be a `Node` to work well with Relay 1 mutations. This just resolves to `query`.
  id: ID!
}

type Question implements Node {
  # A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  id: ID!
  rowId: Int!
  title: NonEmptyText!
  description: NonEmptyText!
  author: Int!

  # Reads and enables paginatation through a set of `Answer`.
  answerSearch(
    # The method to use when ordering `Answer`.
    orderBy: QuestionAnswerSearchOrderBy = NATURAL

    # Read all values in the set before (above) this cursor.
    before: Cursor

    # Read all values in the set after (below) this cursor.
    after: Cursor

    # Only read the first `n` values of the set.
    first: Int

    # Only read the last `n` values of the set.
    last: Int

    # Skip the first `n` values from our `after` cursor, an alternative to cursor
    # based pagination. May not be used with `last`.
    offset: Int
    search: String
  ): QuestionAnswerSearchConnection

  # Reads and enables paginatation through a set of `Answer`.
  answersOrderedByVote(
    # The method to use when ordering `Answer`.
    orderBy: QuestionAnswersOrderedByVoteOrderBy = NATURAL

    # Read all values in the set before (above) this cursor.
    before: Cursor

    # Read all values in the set after (below) this cursor.
    after: Cursor

    # Only read the first `n` values of the set.
    first: Int

    # Only read the last `n` values of the set.
    last: Int

    # Skip the first `n` values from our `after` cursor, an alternative to cursor
    # based pagination. May not be used with `last`.
    offset: Int
  ): QuestionAnswersOrderedByVoteConnection
  vote: Int

  # Reads a single `User` that is related to this `Question`.
  userByAuthor: User

  # Reads and enables paginatation through a set of `Answer`.
  answersByQuestion(
    # The method to use when ordering `Answer`.
    orderBy: AnswersOrderBy = PRIMARY_KEY_ASC

    # Read all values in the set before (above) this cursor.
    before: Cursor

    # Read all values in the set after (below) this cursor.
    after: Cursor

    # Only read the first `n` values of the set.
    first: Int

    # Only read the last `n` values of the set.
    last: Int

    # Skip the first `n` values from our `after` cursor, an alternative to cursor
    # based pagination. May not be used with `last`.
    offset: Int

    # A condition to be used in determining which values should be returned by the collection.
    condition: AnswerCondition
  ): AnswersConnection

  # Reads and enables paginatation through a set of `AnswerVote`.
  answerVotesByQuestion(
    # The method to use when ordering `AnswerVote`.
    orderBy: AnswerVotesOrderBy = PRIMARY_KEY_ASC

    # Read all values in the set before (above) this cursor.
    before: Cursor

    # Read all values in the set after (below) this cursor.
    after: Cursor

    # Only read the first `n` values of the set.
    first: Int

    # Only read the last `n` values of the set.
    last: Int

    # Skip the first `n` values from our `after` cursor, an alternative to cursor
    # based pagination. May not be used with `last`.
    offset: Int

    # A condition to be used in determining which values should be returned by the collection.
    condition: AnswerVoteCondition
  ): AnswerVotesConnection

  # Reads and enables paginatation through a set of `QuestionVote`.
  questionVotesByQuestion(
    # The method to use when ordering `QuestionVote`.
    orderBy: QuestionVotesOrderBy = PRIMARY_KEY_ASC

    # Read all values in the set before (above) this cursor.
    before: Cursor

    # Read all values in the set after (below) this cursor.
    after: Cursor

    # Only read the first `n` values of the set.
    first: Int

    # Only read the last `n` values of the set.
    last: Int

    # Skip the first `n` values from our `after` cursor, an alternative to cursor
    # based pagination. May not be used with `last`.
    offset: Int

    # A condition to be used in determining which values should be returned by the collection.
    condition: QuestionVoteCondition
  ): QuestionVotesConnection

  # Reads and enables paginatation through a set of `QuestionTag`.
  questionTagsByQuestion(
    # The method to use when ordering `QuestionTag`.
    orderBy: QuestionTagsOrderBy = NATURAL

    # Read all values in the set before (above) this cursor.
    before: Cursor

    # Read all values in the set after (below) this cursor.
    after: Cursor

    # Only read the first `n` values of the set.
    first: Int

    # Only read the last `n` values of the set.
    last: Int

    # Skip the first `n` values from our `after` cursor, an alternative to cursor
    # based pagination. May not be used with `last`.
    offset: Int

    # A condition to be used in determining which values should be returned by the collection.
    condition: QuestionTagCondition
  ): QuestionTagsConnection

  # Reads and enables paginatation through a set of `QuestionModel`.
  questionModelsByQuestionid(
    # The method to use when ordering `QuestionModel`.
    orderBy: QuestionModelsOrderBy = NATURAL

    # Read all values in the set before (above) this cursor.
    before: Cursor

    # Read all values in the set after (below) this cursor.
    after: Cursor

    # Only read the first `n` values of the set.
    first: Int

    # Only read the last `n` values of the set.
    last: Int

    # Skip the first `n` values from our `after` cursor, an alternative to cursor
    # based pagination. May not be used with `last`.
    offset: Int

    # A condition to be used in determining which values should be returned by the collection.
    condition: QuestionModelCondition
  ): QuestionModelsConnection
}

# A connection to a list of `Answer` values.
type QuestionAnswerSearchConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # The count of *all* `Answer` you could get from the connection.
  totalCount: Int

  # A list of edges which contains the `Answer` and cursor to aid in pagination.
  edges: [QuestionAnswerSearchEdge]

  # A list of `Answer` objects.
  nodes: [Answer]
}

# A `Answer` edge in the connection.
type QuestionAnswerSearchEdge {
  # A cursor for use in pagination.
  cursor: Cursor

  # The `Answer` at the end of the edge.
  node: Answer
}

# Methods to use when ordering `Answer`.
enum QuestionAnswerSearchOrderBy {
  NATURAL
}

# A connection to a list of `Answer` values.
type QuestionAnswersOrderedByVoteConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # The count of *all* `Answer` you could get from the connection.
  totalCount: Int

  # A list of edges which contains the `Answer` and cursor to aid in pagination.
  edges: [QuestionAnswersOrderedByVoteEdge]

  # A list of `Answer` objects.
  nodes: [Answer]
}

# A `Answer` edge in the connection.
type QuestionAnswersOrderedByVoteEdge {
  # A cursor for use in pagination.
  cursor: Cursor

  # The `Answer` at the end of the edge.
  node: Answer
}

# Methods to use when ordering `Answer`.
enum QuestionAnswersOrderedByVoteOrderBy {
  NATURAL
}

# A condition to be used against `Question` object types. All fields are tested
# for equality and combined with a logical ‘and.’
input QuestionCondition {
  # Checks for equality with the object’s `rowId` field.
  rowId: Int

  # Checks for equality with the object’s `title` field.
  title: NonEmptyText

  # Checks for equality with the object’s `description` field.
  description: NonEmptyText

  # Checks for equality with the object’s `author` field.
  author: Int
}

input QuestionInput {
  rowId: Int
  title: NonEmptyText!
  description: NonEmptyText!
  author: Int!
}

type QuestionModel {
  questionid: Int!
  name: String
  value: String
  source: String
  min: Int
  max: Int
  step: Float

  # Reads a single `Question` that is related to this `QuestionModel`.
  questionByQuestionid: Question
}

# A condition to be used against `QuestionModel` object types. All fields are
# tested for equality and combined with a logical ‘and.’
input QuestionModelCondition {
  # Checks for equality with the object’s `questionid` field.
  questionid: Int

  # Checks for equality with the object’s `name` field.
  name: String

  # Checks for equality with the object’s `value` field.
  value: String

  # Checks for equality with the object’s `source` field.
  source: String

  # Checks for equality with the object’s `min` field.
  min: Int

  # Checks for equality with the object’s `max` field.
  max: Int

  # Checks for equality with the object’s `step` field.
  step: Float
}

input QuestionModelInput {
  questionid: Int
  name: String
  value: String
  source: String
  min: Int
  max: Int
  step: Float
}

# A connection to a list of `QuestionModel` values.
type QuestionModelsConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # The count of *all* `QuestionModel` you could get from the connection.
  totalCount: Int

  # A list of edges which contains the `QuestionModel` and cursor to aid in pagination.
  edges: [QuestionModelsEdge]

  # A list of `QuestionModel` objects.
  nodes: [QuestionModel!]
}

# A `QuestionModel` edge in the connection.
type QuestionModelsEdge {
  # A cursor for use in pagination.
  cursor: Cursor

  # The `QuestionModel` at the end of the edge.
  node: QuestionModel!
}

# Methods to use when ordering `QuestionModel`.
enum QuestionModelsOrderBy {
  NATURAL
  QUESTIONID_ASC
  QUESTIONID_DESC
  NAME_ASC
  NAME_DESC
  VALUE_ASC
  VALUE_DESC
  SOURCE_ASC
  SOURCE_DESC
  MIN_ASC
  MIN_DESC
  MAX_ASC
  MAX_DESC
  STEP_ASC
  STEP_DESC
}

# Represents an update to a `Question`. Fields that are set will be updated.
input QuestionPatch {
  rowId: Int
  title: NonEmptyText
  description: NonEmptyText
  author: Int
}

# A connection to a list of `Question` values.
type QuestionsConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # The count of *all* `Question` you could get from the connection.
  totalCount: Int

  # A list of edges which contains the `Question` and cursor to aid in pagination.
  edges: [QuestionsEdge]

  # A list of `Question` objects.
  nodes: [Question!]
}

# A `Question` edge in the connection.
type QuestionsEdge {
  # A cursor for use in pagination.
  cursor: Cursor

  # The `Question` at the end of the edge.
  node: Question!
}

# Methods to use when ordering `Question`.
enum QuestionsOrderBy {
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  NATURAL
  ID_ASC
  ID_DESC
  TITLE_ASC
  TITLE_DESC
  DESCRIPTION_ASC
  DESCRIPTION_DESC
  AUTHOR_ASC
  AUTHOR_DESC
}

type QuestionTag {
  question: Int
  tag: Int

  # Reads a single `Question` that is related to this `QuestionTag`.
  questionByQuestion: Question

  # Reads a single `Tag` that is related to this `QuestionTag`.
  tagByTag: Tag
}

# A condition to be used against `QuestionTag` object types. All fields are tested
# for equality and combined with a logical ‘and.’
input QuestionTagCondition {
  # Checks for equality with the object’s `question` field.
  question: Int

  # Checks for equality with the object’s `tag` field.
  tag: Int
}

input QuestionTagInput {
  question: Int
  tag: Int
}

# A connection to a list of `QuestionTag` values.
type QuestionTagsConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # The count of *all* `QuestionTag` you could get from the connection.
  totalCount: Int

  # A list of edges which contains the `QuestionTag` and cursor to aid in pagination.
  edges: [QuestionTagsEdge]

  # A list of `QuestionTag` objects.
  nodes: [QuestionTag!]
}

# A `QuestionTag` edge in the connection.
type QuestionTagsEdge {
  # A cursor for use in pagination.
  cursor: Cursor

  # The `QuestionTag` at the end of the edge.
  node: QuestionTag!
}

# Methods to use when ordering `QuestionTag`.
enum QuestionTagsOrderBy {
  NATURAL
  QUESTION_ASC
  QUESTION_DESC
  TAG_ASC
  TAG_DESC
}

type QuestionVote implements Node {
  # A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  id: ID!
  user: Int!
  question: Int!
  subscribe: Boolean
  value: PositiveOrNegativeOne

  # Reads a single `User` that is related to this `QuestionVote`.
  userByUser: User

  # Reads a single `Question` that is related to this `QuestionVote`.
  questionByQuestion: Question
}

# A condition to be used against `QuestionVote` object types. All fields are
# tested for equality and combined with a logical ‘and.’
input QuestionVoteCondition {
  # Checks for equality with the object’s `user` field.
  user: Int

  # Checks for equality with the object’s `question` field.
  question: Int

  # Checks for equality with the object’s `subscribe` field.
  subscribe: Boolean

  # Checks for equality with the object’s `value` field.
  value: PositiveOrNegativeOne
}

input QuestionVoteInput {
  user: Int!
  question: Int!
  subscribe: Boolean
  value: PositiveOrNegativeOne
}

# Represents an update to a `QuestionVote`. Fields that are set will be updated.
input QuestionVotePatch {
  user: Int
  question: Int
  subscribe: Boolean
  value: PositiveOrNegativeOne
}

# A connection to a list of `QuestionVote` values.
type QuestionVotesConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # The count of *all* `QuestionVote` you could get from the connection.
  totalCount: Int

  # A list of edges which contains the `QuestionVote` and cursor to aid in pagination.
  edges: [QuestionVotesEdge]

  # A list of `QuestionVote` objects.
  nodes: [QuestionVote!]
}

# A `QuestionVote` edge in the connection.
type QuestionVotesEdge {
  # A cursor for use in pagination.
  cursor: Cursor

  # The `QuestionVote` at the end of the edge.
  node: QuestionVote!
}

# Methods to use when ordering `QuestionVote`.
enum QuestionVotesOrderBy {
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  NATURAL
  USER_ASC
  USER_DESC
  QUESTION_ASC
  QUESTION_DESC
  SUBSCRIBE_ASC
  SUBSCRIBE_DESC
  VALUE_ASC
  VALUE_DESC
}

# All input for the `registerUser` mutation.
input RegisterUserInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String
  firstName: String!
  lastName: String!
  username: String!
  email: String!
  password: String!
}

# The output of our `registerUser` mutation.
type RegisterUserPayload {
  # The exact same `clientMutationId` that was provided in the mutation input,
  # unchanged and unused. May be used by a client to track mutations.
  clientMutationId: String
  user: User

  # An edge for the type. May be used by Relay 1.
  userEdge(
    # The method to use when ordering `User`.
    orderBy: UsersOrderBy = PRIMARY_KEY_ASC
  ): UsersEdge

  # Our root query field type. Allows us to run any query from our mutation payload.
  query: Query
}

# A connection to a list of `Answer` values.
type SearchAnswersConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # The count of *all* `Answer` you could get from the connection.
  totalCount: Int

  # A list of edges which contains the `Answer` and cursor to aid in pagination.
  edges: [SearchAnswersEdge]

  # A list of `Answer` objects.
  nodes: [Answer]
}

# A `Answer` edge in the connection.
type SearchAnswersEdge {
  # A cursor for use in pagination.
  cursor: Cursor

  # The `Answer` at the end of the edge.
  node: Answer
}

# Methods to use when ordering `Answer`.
enum SearchAnswersOrderBy {
  NATURAL
}

# A connection to a list of `Question` values.
type SearchQuestionsConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # The count of *all* `Question` you could get from the connection.
  totalCount: Int

  # A list of edges which contains the `Question` and cursor to aid in pagination.
  edges: [SearchQuestionsEdge]

  # A list of `Question` objects.
  nodes: [Question]
}

# A `Question` edge in the connection.
type SearchQuestionsEdge {
  # A cursor for use in pagination.
  cursor: Cursor

  # The `Question` at the end of the edge.
  node: Question
}

# Methods to use when ordering `Question`.
enum SearchQuestionsOrderBy {
  NATURAL
}

# A connection to a list of `Tag` values.
type SearchTagsConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # The count of *all* `Tag` you could get from the connection.
  totalCount: Int

  # A list of edges which contains the `Tag` and cursor to aid in pagination.
  edges: [SearchTagsEdge]

  # A list of `Tag` objects.
  nodes: [Tag]
}

# A `Tag` edge in the connection.
type SearchTagsEdge {
  # A cursor for use in pagination.
  cursor: Cursor

  # The `Tag` at the end of the edge.
  node: Tag
}

# Methods to use when ordering `Tag`.
enum SearchTagsOrderBy {
  NATURAL
}

type Tag implements Node {
  # A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  id: ID!
  rowId: Int!
  name: String
  description: String
  parent: Int

  # Reads a single `Tag` that is related to this `Tag`.
  tagByParent: Tag

  # Reads and enables paginatation through a set of `Tag`.
  tagsByParent(
    # The method to use when ordering `Tag`.
    orderBy: TagsOrderBy = PRIMARY_KEY_ASC

    # Read all values in the set before (above) this cursor.
    before: Cursor

    # Read all values in the set after (below) this cursor.
    after: Cursor

    # Only read the first `n` values of the set.
    first: Int

    # Only read the last `n` values of the set.
    last: Int

    # Skip the first `n` values from our `after` cursor, an alternative to cursor
    # based pagination. May not be used with `last`.
    offset: Int

    # A condition to be used in determining which values should be returned by the collection.
    condition: TagCondition
  ): TagsConnection

  # Reads and enables paginatation through a set of `QuestionTag`.
  questionTagsByTag(
    # The method to use when ordering `QuestionTag`.
    orderBy: QuestionTagsOrderBy = NATURAL

    # Read all values in the set before (above) this cursor.
    before: Cursor

    # Read all values in the set after (below) this cursor.
    after: Cursor

    # Only read the first `n` values of the set.
    first: Int

    # Only read the last `n` values of the set.
    last: Int

    # Skip the first `n` values from our `after` cursor, an alternative to cursor
    # based pagination. May not be used with `last`.
    offset: Int

    # A condition to be used in determining which values should be returned by the collection.
    condition: QuestionTagCondition
  ): QuestionTagsConnection

  # Reads and enables paginatation through a set of `TagRelation`.
  tagRelationsByTag1(
    # The method to use when ordering `TagRelation`.
    orderBy: TagRelationsOrderBy = PRIMARY_KEY_ASC

    # Read all values in the set before (above) this cursor.
    before: Cursor

    # Read all values in the set after (below) this cursor.
    after: Cursor

    # Only read the first `n` values of the set.
    first: Int

    # Only read the last `n` values of the set.
    last: Int

    # Skip the first `n` values from our `after` cursor, an alternative to cursor
    # based pagination. May not be used with `last`.
    offset: Int

    # A condition to be used in determining which values should be returned by the collection.
    condition: TagRelationCondition
  ): TagRelationsConnection

  # Reads and enables paginatation through a set of `TagRelation`.
  tagRelationsByTag2(
    # The method to use when ordering `TagRelation`.
    orderBy: TagRelationsOrderBy = PRIMARY_KEY_ASC

    # Read all values in the set before (above) this cursor.
    before: Cursor

    # Read all values in the set after (below) this cursor.
    after: Cursor

    # Only read the first `n` values of the set.
    first: Int

    # Only read the last `n` values of the set.
    last: Int

    # Skip the first `n` values from our `after` cursor, an alternative to cursor
    # based pagination. May not be used with `last`.
    offset: Int

    # A condition to be used in determining which values should be returned by the collection.
    condition: TagRelationCondition
  ): TagRelationsConnection
}

# A condition to be used against `Tag` object types. All fields are tested for equality and combined with a logical ‘and.’
input TagCondition {
  # Checks for equality with the object’s `rowId` field.
  rowId: Int

  # Checks for equality with the object’s `name` field.
  name: String

  # Checks for equality with the object’s `description` field.
  description: String

  # Checks for equality with the object’s `parent` field.
  parent: Int
}

input TagInput {
  rowId: Int
  name: String
  description: String
  parent: Int
}

# Represents an update to a `Tag`. Fields that are set will be updated.
input TagPatch {
  rowId: Int
  name: String
  description: String
  parent: Int
}

type TagRelation implements Node {
  # A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  id: ID!
  tag1: Int!
  linkType: LinkType
  tag2: Int

  # Reads a single `Tag` that is related to this `TagRelation`.
  tagByTag1: Tag

  # Reads a single `Tag` that is related to this `TagRelation`.
  tagByTag2: Tag
}

# A condition to be used against `TagRelation` object types. All fields are tested
# for equality and combined with a logical ‘and.’
input TagRelationCondition {
  # Checks for equality with the object’s `tag1` field.
  tag1: Int

  # Checks for equality with the object’s `linkType` field.
  linkType: LinkType

  # Checks for equality with the object’s `tag2` field.
  tag2: Int
}

input TagRelationInput {
  tag1: Int!
  linkType: LinkType
  tag2: Int
}

# Represents an update to a `TagRelation`. Fields that are set will be updated.
input TagRelationPatch {
  tag1: Int
  linkType: LinkType
  tag2: Int
}

# A connection to a list of `TagRelation` values.
type TagRelationsConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # The count of *all* `TagRelation` you could get from the connection.
  totalCount: Int

  # A list of edges which contains the `TagRelation` and cursor to aid in pagination.
  edges: [TagRelationsEdge]

  # A list of `TagRelation` objects.
  nodes: [TagRelation!]
}

# A `TagRelation` edge in the connection.
type TagRelationsEdge {
  # A cursor for use in pagination.
  cursor: Cursor

  # The `TagRelation` at the end of the edge.
  node: TagRelation!
}

# Methods to use when ordering `TagRelation`.
enum TagRelationsOrderBy {
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  NATURAL
  TAG1_ASC
  TAG1_DESC
  LINK_TYPE_ASC
  LINK_TYPE_DESC
  TAG2_ASC
  TAG2_DESC
}

# A connection to a list of `Tag` values.
type TagsByParentConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # The count of *all* `Tag` you could get from the connection.
  totalCount: Int

  # A list of edges which contains the `Tag` and cursor to aid in pagination.
  edges: [TagsByParentEdge]

  # A list of `Tag` objects.
  nodes: [Tag]
}

# A `Tag` edge in the connection.
type TagsByParentEdge {
  # A cursor for use in pagination.
  cursor: Cursor

  # The `Tag` at the end of the edge.
  node: Tag
}

# Methods to use when ordering `Tag`.
enum TagsByParentOrderBy {
  NATURAL
}

# A connection to a list of `Tag` values.
type TagsConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # The count of *all* `Tag` you could get from the connection.
  totalCount: Int

  # A list of edges which contains the `Tag` and cursor to aid in pagination.
  edges: [TagsEdge]

  # A list of `Tag` objects.
  nodes: [Tag!]
}

# A `Tag` edge in the connection.
type TagsEdge {
  # A cursor for use in pagination.
  cursor: Cursor

  # The `Tag` at the end of the edge.
  node: Tag!
}

# Methods to use when ordering `Tag`.
enum TagsOrderBy {
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  NATURAL
  ID_ASC
  ID_DESC
  NAME_ASC
  NAME_DESC
  DESCRIPTION_ASC
  DESCRIPTION_DESC
  PARENT_ASC
  PARENT_DESC
}

# All input for the `updateAnswerByRowId` mutation.
input UpdateAnswerByRowIdInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String
  rowId: Int!

  # An object where the defined keys will be set on the `Answer` identified by our unique key.
  answerPatch: AnswerPatch!
}

# All input for the `updateAnswer` mutation.
input UpdateAnswerInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The globally unique `ID` which will identify a single `Answer` to be updated.
  id: ID!

  # An object where the defined keys will be set on the `Answer` identified by our globally unique `ID`.
  answerPatch: AnswerPatch!
}

# The output of our `updateAnswer` mutation.
type UpdateAnswerPayload {
  # The exact same `clientMutationId` that was provided in the mutation input,
  # unchanged and unused. May be used by a client to track mutations.
  clientMutationId: String
  answer: Answer

  # Reads a single `Question` that is related to this `Answer`.
  questionByQuestion: Question

  # Reads a single `User` that is related to this `Answer`.
  userByAuthor: User

  # Our root query field type. Allows us to run any query from our mutation payload.
  query: Query
}

# All input for the `updateAnswerVoteByUserAndQuestionAndAnswer` mutation.
input UpdateAnswerVoteByUserAndQuestionAndAnswerInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String
  user: Int!
  question: Int!
  answer: Int!

  # An object where the defined keys will be set on the `AnswerVote` identified by our unique key.
  answerVotePatch: AnswerVotePatch!
}

# All input for the `updateAnswerVote` mutation.
input UpdateAnswerVoteInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The globally unique `ID` which will identify a single `AnswerVote` to be updated.
  id: ID!

  # An object where the defined keys will be set on the `AnswerVote` identified by our globally unique `ID`.
  answerVotePatch: AnswerVotePatch!
}

# The output of our `updateAnswerVote` mutation.
type UpdateAnswerVotePayload {
  # The exact same `clientMutationId` that was provided in the mutation input,
  # unchanged and unused. May be used by a client to track mutations.
  clientMutationId: String
  answerVote: AnswerVote

  # Reads a single `User` that is related to this `AnswerVote`.
  userByUser: User

  # Reads a single `Question` that is related to this `AnswerVote`.
  questionByQuestion: Question

  # Reads a single `Answer` that is related to this `AnswerVote`.
  answerByAnswer: Answer

  # Our root query field type. Allows us to run any query from our mutation payload.
  query: Query
}

# All input for the `updateQuestionByRowId` mutation.
input UpdateQuestionByRowIdInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String
  rowId: Int!

  # An object where the defined keys will be set on the `Question` identified by our unique key.
  questionPatch: QuestionPatch!
}

# All input for the `updateQuestion` mutation.
input UpdateQuestionInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The globally unique `ID` which will identify a single `Question` to be updated.
  id: ID!

  # An object where the defined keys will be set on the `Question` identified by our globally unique `ID`.
  questionPatch: QuestionPatch!
}

# The output of our `updateQuestion` mutation.
type UpdateQuestionPayload {
  # The exact same `clientMutationId` that was provided in the mutation input,
  # unchanged and unused. May be used by a client to track mutations.
  clientMutationId: String
  question: Question

  # Reads a single `User` that is related to this `Question`.
  userByAuthor: User

  # Our root query field type. Allows us to run any query from our mutation payload.
  query: Query
}

# All input for the `updateQuestionVoteByUserAndQuestion` mutation.
input UpdateQuestionVoteByUserAndQuestionInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String
  user: Int!
  question: Int!

  # An object where the defined keys will be set on the `QuestionVote` identified by our unique key.
  questionVotePatch: QuestionVotePatch!
}

# All input for the `updateQuestionVote` mutation.
input UpdateQuestionVoteInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The globally unique `ID` which will identify a single `QuestionVote` to be updated.
  id: ID!

  # An object where the defined keys will be set on the `QuestionVote` identified by our globally unique `ID`.
  questionVotePatch: QuestionVotePatch!
}

# The output of our `updateQuestionVote` mutation.
type UpdateQuestionVotePayload {
  # The exact same `clientMutationId` that was provided in the mutation input,
  # unchanged and unused. May be used by a client to track mutations.
  clientMutationId: String
  questionVote: QuestionVote

  # Reads a single `User` that is related to this `QuestionVote`.
  userByUser: User

  # Reads a single `Question` that is related to this `QuestionVote`.
  questionByQuestion: Question

  # Our root query field type. Allows us to run any query from our mutation payload.
  query: Query
}

# All input for the `updateTagByRowId` mutation.
input UpdateTagByRowIdInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String
  rowId: Int!

  # An object where the defined keys will be set on the `Tag` identified by our unique key.
  tagPatch: TagPatch!
}

# All input for the `updateTag` mutation.
input UpdateTagInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The globally unique `ID` which will identify a single `Tag` to be updated.
  id: ID!

  # An object where the defined keys will be set on the `Tag` identified by our globally unique `ID`.
  tagPatch: TagPatch!
}

# The output of our `updateTag` mutation.
type UpdateTagPayload {
  # The exact same `clientMutationId` that was provided in the mutation input,
  # unchanged and unused. May be used by a client to track mutations.
  clientMutationId: String
  tag: Tag

  # Reads a single `Tag` that is related to this `Tag`.
  tagByParent: Tag

  # Our root query field type. Allows us to run any query from our mutation payload.
  query: Query
}

# All input for the `updateTagRelationByTag1` mutation.
input UpdateTagRelationByTag1Input {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String
  tag1: Int!

  # An object where the defined keys will be set on the `TagRelation` identified by our unique key.
  tagRelationPatch: TagRelationPatch!
}

# All input for the `updateTagRelation` mutation.
input UpdateTagRelationInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The globally unique `ID` which will identify a single `TagRelation` to be updated.
  id: ID!

  # An object where the defined keys will be set on the `TagRelation` identified by our globally unique `ID`.
  tagRelationPatch: TagRelationPatch!
}

# The output of our `updateTagRelation` mutation.
type UpdateTagRelationPayload {
  # The exact same `clientMutationId` that was provided in the mutation input,
  # unchanged and unused. May be used by a client to track mutations.
  clientMutationId: String
  tagRelation: TagRelation

  # Reads a single `Tag` that is related to this `TagRelation`.
  tagByTag1: Tag

  # Reads a single `Tag` that is related to this `TagRelation`.
  tagByTag2: Tag

  # Our root query field type. Allows us to run any query from our mutation payload.
  query: Query
}

# All input for the `updateUserByRowId` mutation.
input UpdateUserByRowIdInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String
  rowId: Int!

  # An object where the defined keys will be set on the `User` identified by our unique key.
  userPatch: UserPatch!
}

# All input for the `updateUserByUsername` mutation.
input UpdateUserByUsernameInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String
  username: NonEmptyText!

  # An object where the defined keys will be set on the `User` identified by our unique key.
  userPatch: UserPatch!
}

# All input for the `updateUser` mutation.
input UpdateUserInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The globally unique `ID` which will identify a single `User` to be updated.
  id: ID!

  # An object where the defined keys will be set on the `User` identified by our globally unique `ID`.
  userPatch: UserPatch!
}

# The output of our `updateUser` mutation.
type UpdateUserPayload {
  # The exact same `clientMutationId` that was provided in the mutation input,
  # unchanged and unused. May be used by a client to track mutations.
  clientMutationId: String
  user: User

  # Our root query field type. Allows us to run any query from our mutation payload.
  query: Query
}

# All input for the `upsertAnswerVoteByQuestionAndAnswer` mutation.
input UpsertAnswerVoteByQuestionAndAnswerInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String
  questionId: Int
  answerId: Int
  value: Int
  subscribe: Boolean
}

# The output of our `upsertAnswerVoteByQuestionAndAnswer` mutation.
type UpsertAnswerVoteByQuestionAndAnswerPayload {
  # The exact same `clientMutationId` that was provided in the mutation input,
  # unchanged and unused. May be used by a client to track mutations.
  clientMutationId: String
  answer: Answer

  # An edge for the type. May be used by Relay 1.
  answerEdge(
    # The method to use when ordering `Answer`.
    orderBy: AnswersOrderBy = PRIMARY_KEY_ASC
  ): AnswersEdge

  # Reads a single `Question` that is related to this `Answer`.
  questionByQuestion: Question

  # Reads a single `User` that is related to this `Answer`.
  userByAuthor: User

  # Our root query field type. Allows us to run any query from our mutation payload.
  query: Query
}

# All input for the `upsertTest` mutation.
input UpsertTestInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String
  questionId: Int
  answerId: Int
  value: Int
  subscribe: Boolean
}

# The output of our `upsertTest` mutation.
type UpsertTestPayload {
  # The exact same `clientMutationId` that was provided in the mutation input,
  # unchanged and unused. May be used by a client to track mutations.
  clientMutationId: String
  boolean: Boolean

  # Our root query field type. Allows us to run any query from our mutation payload.
  query: Query
}

type User implements Node {
  # A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  id: ID!
  rowId: Int!
  username: NonEmptyText
  firstName: String
  lastName: String
  createdAt: Datetime
  fullName: String

  # Reads and enables paginatation through a set of `Question`.
  questionsByAuthor(
    # The method to use when ordering `Question`.
    orderBy: QuestionsOrderBy = PRIMARY_KEY_ASC

    # Read all values in the set before (above) this cursor.
    before: Cursor

    # Read all values in the set after (below) this cursor.
    after: Cursor

    # Only read the first `n` values of the set.
    first: Int

    # Only read the last `n` values of the set.
    last: Int

    # Skip the first `n` values from our `after` cursor, an alternative to cursor
    # based pagination. May not be used with `last`.
    offset: Int

    # A condition to be used in determining which values should be returned by the collection.
    condition: QuestionCondition
  ): QuestionsConnection

  # Reads and enables paginatation through a set of `Answer`.
  answersByAuthor(
    # The method to use when ordering `Answer`.
    orderBy: AnswersOrderBy = PRIMARY_KEY_ASC

    # Read all values in the set before (above) this cursor.
    before: Cursor

    # Read all values in the set after (below) this cursor.
    after: Cursor

    # Only read the first `n` values of the set.
    first: Int

    # Only read the last `n` values of the set.
    last: Int

    # Skip the first `n` values from our `after` cursor, an alternative to cursor
    # based pagination. May not be used with `last`.
    offset: Int

    # A condition to be used in determining which values should be returned by the collection.
    condition: AnswerCondition
  ): AnswersConnection

  # Reads and enables paginatation through a set of `AnswerVote`.
  answerVotesByUser(
    # The method to use when ordering `AnswerVote`.
    orderBy: AnswerVotesOrderBy = PRIMARY_KEY_ASC

    # Read all values in the set before (above) this cursor.
    before: Cursor

    # Read all values in the set after (below) this cursor.
    after: Cursor

    # Only read the first `n` values of the set.
    first: Int

    # Only read the last `n` values of the set.
    last: Int

    # Skip the first `n` values from our `after` cursor, an alternative to cursor
    # based pagination. May not be used with `last`.
    offset: Int

    # A condition to be used in determining which values should be returned by the collection.
    condition: AnswerVoteCondition
  ): AnswerVotesConnection

  # Reads and enables paginatation through a set of `QuestionVote`.
  questionVotesByUser(
    # The method to use when ordering `QuestionVote`.
    orderBy: QuestionVotesOrderBy = PRIMARY_KEY_ASC

    # Read all values in the set before (above) this cursor.
    before: Cursor

    # Read all values in the set after (below) this cursor.
    after: Cursor

    # Only read the first `n` values of the set.
    first: Int

    # Only read the last `n` values of the set.
    last: Int

    # Skip the first `n` values from our `after` cursor, an alternative to cursor
    # based pagination. May not be used with `last`.
    offset: Int

    # A condition to be used in determining which values should be returned by the collection.
    condition: QuestionVoteCondition
  ): QuestionVotesConnection
}

# A condition to be used against `User` object types. All fields are tested for equality and combined with a logical ‘and.’
input UserCondition {
  # Checks for equality with the object’s `rowId` field.
  rowId: Int

  # Checks for equality with the object’s `username` field.
  username: NonEmptyText

  # Checks for equality with the object’s `firstName` field.
  firstName: String

  # Checks for equality with the object’s `lastName` field.
  lastName: String

  # Checks for equality with the object’s `createdAt` field.
  createdAt: Datetime
}

input UserInput {
  rowId: Int
  username: NonEmptyText
  firstName: String
  lastName: String
  createdAt: Datetime
}

# Represents an update to a `User`. Fields that are set will be updated.
input UserPatch {
  rowId: Int
  username: NonEmptyText
  firstName: String
  lastName: String
  createdAt: Datetime
}

# A connection to a list of `User` values.
type UsersConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # The count of *all* `User` you could get from the connection.
  totalCount: Int

  # A list of edges which contains the `User` and cursor to aid in pagination.
  edges: [UsersEdge]

  # A list of `User` objects.
  nodes: [User!]
}

# A `User` edge in the connection.
type UsersEdge {
  # A cursor for use in pagination.
  cursor: Cursor

  # The `User` at the end of the edge.
  node: User!
}

# Methods to use when ordering `User`.
enum UsersOrderBy {
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  NATURAL
  ID_ASC
  ID_DESC
  USERNAME_ASC
  USERNAME_DESC
  FIRST_NAME_ASC
  FIRST_NAME_DESC
  LAST_NAME_ASC
  LAST_NAME_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
}

# A universally unique identifier as defined by [RFC 4122](https://tools.ietf.org/html/rfc4122).
scalar Uuid
